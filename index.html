<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <!-- jquery -->
  <script src="https://apps.bdimg.com/libs/jquery/1.10.2/jquery.min.js"></script>
  <script src="https://apps.bdimg.com/libs/jqueryui/1.10.4/jquery-ui.min.js"></script>

  <link rel="stylesheet" href="/css/main.css">
  <script src="/js/main.js"></script>
</head>

<body onload="my_load()">

  <div class="menu_box">

    <div class="menu_item" id="switch_video" onclick="switch_video()">
      <span>
        hide
      </span>
    </div>

    <div class="menu_item" id="pause_video" onclick="pause_video()">
      <span>
        pause
      </span>
    </div>

    <div class="bar_box">
      <div class="progress_box" id="total_progress">
        <div class="seek_box" id="cur_progress"></div>
      </div>
    </div>

    <div class="bar_box">
      <div class="progress_box" id="total_speed">
        <div class="seek_box" id="cur_speed"></div>
      </div>
    </div>

  </div>

  <video class="main_video" id="main_video">
  </video>

  <div class="main_article">
    <h1>1 引论</h1>
    <ul>
      <li onclick="load_video(1, 0, 33, 40)">编译器的作用</li>
      <li onclick="load_video(1, 0, 37, 04)">编译器的结构</li>
      <li onclick="load_video(1, 0, 42, 22)">词法分析</li>
      <li onclick="load_video(1, 0, 44, 47)">语法分析</li>
      <li onclick="load_video(1, 0, 46, 18)">语义分析</li>
      <li onclick="load_video(1, 0, 47, 39)">中间代码生成</li>
      <li onclick="load_video(1, 0, 48, 51)">中间代码优化</li>
      <li onclick="load_video(1, 0, 50, 3)">代码生成</li>
      <li onclick="load_video(1, 0, 51, 11)">其他概念</li>
      <li onclick="load_video(1, 0, 53, 23)">程序设计语言的发展历程</li>
      <li onclick="load_video(1, 0, 54, 54)">语言和编译器之间的关系</li>
      <li onclick="load_video(1, 0, 55, 34)">编译技术的应用</li>
      <li onclick="load_video(1, 0, 56, 10)">程序设计语言的基础概念</li>
    </ul>
    <h1>3 词法分析</h1>
    <ul>
      <li onclick="load_video(2, 0, 2, 31)">词法分析器的作用</li>
      <li onclick="load_video(2, 0, 4, 48)">词法单元、模式、词素</li>
      <li onclick="load_video(2, 0, 11, 33)">词法单元的属性</li>
      <li onclick="load_video(2, 0, 12, 41)">词法单元的归约</li>
      <li onclick="load_video(2, 0, 13, 21)">串和语言</li>
      <li onclick="load_video(3, 0, 0, 0)">正则表达式</li>
      <li onclick="load_video(3, 0, 6, 35)">正则定义</li>
      <li onclick="load_video(3, 0, 9, 51)">正则表达式的扩展</li>
      <li onclick="load_video(3, 0, 12, 32)">词法单元的识别</li>
      <li onclick="load_video(3, 0, 19, 43)">状态转换图</li>
      <li onclick="load_video(3, 0, 24, 14)">保留字和标识符的识别</li>
      <li onclick="load_video(3, 0, 26, 57)">其它的状态转换图</li>
      <li onclick="load_video(3, 0, 30, 57)">词法分析器的体系结构</li>
      <li onclick="load_video(3, 0, 32, 58)">Relop对应的代码概要</li>
      <li onclick="load_video(3, 0, 36, 39)">词法分析工具Lex/Flex</li>
      <li onclick="load_video(3, 0, 39, 37)">Lex源程序的结构</li>
      <li onclick="load_video(3, 0, 40, 37)">Lex程序的例子</li>
      <li onclick="load_video(3, 0, 48, 31)">Lex中冲突解决方法</li>
      <li onclick="load_video(3, 0, 51, 1)">有穷自动机</li>
      <li onclick="load_video(3, 0, 54, 31)">不确定的有穷自动机</li>
      <li onclick="load_video(3, 0, 56, 47)">NFA的例子</li>
      <li onclick="load_video(3, 0, 58, 44)">转换表的表示法</li>
      <li onclick="load_video(3, 0, 59, 43)">输入字符串的接受</li>
      <li onclick="load_video(3, 1, 1, 20)">NFA和相应语言的例子</li>
      <li onclick="load_video(3, 1, 2, 48)">确定的有穷自动机(DFA)</li>
      <li onclick="load_video(3, 1, 3, 46)">DFA的模拟运行</li>
      <li onclick="load_video(4, 0, 0, 0)">作业1</li>
      <li onclick="load_video(5, 0, 0, 0)">实验1</li>
      <li onclick="load_video(6, 0, 0, 0)">从正则表达式到自动机的转换</li>
      <li onclick="load_video(6, 0, 3, 18)">NFA到DFA(子集构造法)</li>
      <li onclick="load_video(7, 0, 0, 0)">子集构造法(图解)</li>
      <li onclick="load_video(8, 0, 0, 0)">NFA到DFA(子集构造法)</li>
      <li onclick="load_video(8, 0, 11, 51)">子集构造法的例子</li>
      <li onclick="load_video(8, 0, 14, 35)">正则表达式到NFA</li>
      <li onclick="load_video(8, 0, 15, 35)">转换算法</li>
      <li onclick="load_video(8, 0, 21, 43)">NFA合并的方法</li>
      <li onclick="load_video(8, 0, 24, 43)">确定化NFA后的处理</li>
      <li onclick="load_video(8, 0, 33, 26)">DFA状态数量的最小化</li>
      <li onclick="load_video(8, 0, 38, 54)">状态的区分</li>
      <li onclick="load_video(8, 0, 41, 59)">DFA最小化算法</li>
      <li onclick="load_video(8, 0, 44, 40)">最小化算法(划分部分)</li>
      <li onclick="load_video(8, 0, 46, 55)">最小化算法(构造部分)</li>
      <li onclick="load_video(8, 0, 48, 12)">DFA最小化的例子</li>
      <li onclick="load_video(8, 0, 54, 16)">词法分析器状态的最小化</li>
    </ul>
    <h1>4 语法分析</h1>
    <ul>
      <li onclick="load_video(9, 0, 5, 44)">程序设计语言构造的描述</li>
      <li onclick="load_video(9, 0, 7, 55)">语法分析器的作用</li>
      <li onclick="load_video(9, 0, 11, 10)">语法分析器的分类</li>
      <li onclick="load_video(9, 0, 13, 38)">上下文无关文法</li>
      <li onclick="load_video(9, 0, 23, 49)">文法简单形式的例子</li>
      <li onclick="load_video(9, 0, 24, 57)">推导</li>
      <li onclick="load_video(9, 0, 31, 44)">句型/句子/语言</li>
      <li onclick="load_video(9, 0, 35, 2)">语法分析树</li>
      <li onclick="load_video(9, 0, 41, 45)">从推导序列构造分析树的例子</li>
      <li onclick="load_video(9, 0, 42, 22)">二义性</li>
      <li onclick="load_video(9, 0, 50, 12)">词法分析和语法分析的比较</li>
      <li onclick="load_video(9, 0, 52, 2)">上下文无关文法和正则表达式</li>
      <li onclick="load_video(9, 1, 3, 44)">NFA构造文法的例子</li>
      <li onclick="load_video(9, 1, 6, 44)">文法及其生成的语言</li>
      <li onclick="load_video(9, 1, 11, 38)">设计文法</li>
      <li onclick="load_video(9, 1, 14, 29)">二义性的消除</li>
      <li onclick="load_video(10, 0, 0, 0)">二义性(图解)</li>
      <li onclick="load_video(11, 0, 0, 0)">作业2</li>
      <li onclick="load_video(12, 0, 0, 0)">左递归的消除</li>
      <li onclick="load_video(12, 0, 2, 32)">立即左递归的消除</li>
      <li onclick="load_video(12, 0, 11, 2)">消除多步左递归</li>
      <li onclick="load_video(12, 0, 11, 52)">通用的左递归消除方法</li>
      <li onclick="load_video(12, 0, 21, 57)">预测分析法简介</li>
      <li onclick="load_video(12, 0, 28, 0)">提取公因子的文法变换</li>
      <li onclick="load_video(12, 0, 28, 36)">自顶向下的语法分析</li>
      <li onclick="load_video(12, 0, 38, 14)">递归下降的语法分析</li>
      <li onclick="load_video(12, 0, 42, 28)">递归下降分析技术的回溯</li>
      <li onclick="load_video(12, 0, 51, 34)">FIRST和FOLLOW</li>
      <li onclick="load_video(12, 0, 55, 43)">FIRST</li>
      <li onclick="load_video(12, 0, 57, 57)">FIRST的计算方法</li>
      <li onclick="load_video(12, 0, 58, 55)">FOLLOW</li>
      <li onclick="load_video(12, 1, 0, 56)">FOLLOW的计算方法</li>
      <li onclick="load_video(12, 1, 2, 31)">FIRST/FOLLOW的例子</li>
      <li onclick="load_video(12, 1, 2, 31)">LL(1)文法</li>
      <li onclick="load_video(12, 1, 2, 31)">预测分析表构造算法</li>
      <li onclick="load_video(12, 1, 2, 31)">预测分析表冲突的例子</li>
      <li onclick="load_video(12, 1, 2, 31)">LL(1)文法的递归下降分析</li>
      <li onclick="load_video(12, 1, 2, 31)">非递归的预测分析</li>
      <li onclick="load_video(3, 0, 2, 31)">分析表驱动的预测分析器</li>
      <li onclick="load_video(3, 0, 2, 31)">预测分析算法</li>
      <li onclick="load_video(3, 0, 2, 31)">自底向上的语法分析</li>
      <li onclick="load_video(3, 0, 2, 31)">归约</li>
      <li onclick="load_video(3, 0, 2, 31)">句柄</li>
      <li onclick="load_video(3, 0, 2, 31)">移入-归约分析技术</li>
      <li onclick="load_video(3, 0, 2, 31)">主要分析动作</li>
      <li onclick="load_video(3, 0, 2, 31)">归约分析过程的例子</li>
      <li onclick="load_video(3, 0, 2, 31)">为什么句柄总是在栈顶</li>
      <li onclick="load_video(3, 0, 2, 31)">移入-归约分析中的冲突</li>
      <li onclick="load_video(3, 0, 2, 31)">移入-归约冲突冲突的例子</li>
      <li onclick="load_video(3, 0, 2, 31)">归约-归约冲突冲突的例子</li>
      <li onclick="load_video(3, 0, 2, 31)">LR语法分析技术</li>
      <li onclick="load_video(3, 0, 2, 31)">LR语法分析器的优点</li>
      <li onclick="load_video(3, 0, 2, 31)">LR(0)项</li>
      <li onclick="load_video(3, 0, 2, 31)">LR(0)项集规范族的构造</li>
      <li onclick="load_video(3, 0, 2, 31)">项集闭包CLOSURE</li>
      <li onclick="load_video(3, 0, 2, 31)">CLOSURE(I)的构造算法</li>
      <li onclick="load_video(3, 0, 2, 31)">GOTO函数</li>
      <li onclick="load_video(3, 0, 2, 31)">求LR(0)项集规范族的算法</li>
      <li onclick="load_video(3, 0, 2, 31)">项集规范族构造示例</li>
      <li onclick="load_video(3, 0, 2, 31)">LR(0)自动机的构造</li>
      <li onclick="load_video(3, 0, 2, 31)">LR(0)自动机的作用</li>
      <li onclick="load_video(3, 0, 2, 31)">LR语法分析器的结构</li>
      <li onclick="load_video(3, 0, 2, 31)">LR语法分析表的结构</li>
      <li onclick="load_video(3, 0, 2, 31)">LR语法分析器的格局</li>
      <li onclick="load_video(3, 0, 2, 31)">LR语法分析器的行为</li>
      <li onclick="load_video(3, 0, 2, 31)">LR语法分析算法</li>
      <li onclick="load_video(3, 0, 2, 31)">LR分析表的例子</li>
      <li onclick="load_video(3, 0, 2, 31)">LR分析过程的例子</li>
      <li onclick="load_video(3, 0, 2, 31)">SLR语法分析表的构造</li>
      <li onclick="load_video(3, 0, 2, 31)">非SLR文法的例子</li>
      <li onclick="load_video(3, 0, 2, 31)">SLR语法分析器的弱点</li>
      <li onclick="load_video(3, 0, 2, 31)">更强大的LR语法分析器</li>
      <li onclick="load_video(3, 0, 2, 31)">LR(1)项</li>
      <li onclick="load_video(3, 0, 2, 31)">LR(1)项和前缀</li>
      <li onclick="load_video(3, 0, 2, 31)">构造LR(1)项集</li>
      <li onclick="load_video(3, 0, 2, 31)">LR(1)项集的CLOSURE算法</li>
      <li onclick="load_video(3, 0, 2, 31)">LR(1)项集的GOTO算法</li>
      <li onclick="load_video(3, 0, 2, 31)">LR(1)项集族的构造算法</li>
      <li onclick="load_video(3, 0, 2, 31)">LR(1)项集族的GOTO图</li>
      <li onclick="load_video(3, 0, 2, 31)">LR(1)语法分析表的构造</li>
      <li onclick="load_video(3, 0, 2, 31)">构造LALR语法分析表</li>
      <li onclick="load_video(3, 0, 2, 31)">LR(1)语法分析表的合并</li>
      <li onclick="load_video(3, 0, 2, 31)">LALR分析技术的基本思想</li>
      <li onclick="load_video(3, 0, 2, 31)">合并引起的冲突</li>
      <li onclick="load_video(3, 0, 2, 31)">合并引起归约/归约冲突的例子</li>
      <li onclick="load_video(3, 0, 2, 31)">LALR分析表构造算法</li>
      <li onclick="load_video(3, 0, 2, 31)">LALR分析器和LR分析器</li>
      <li onclick="load_video(3, 0, 2, 31)">LALR技术本质</li>
      <li onclick="load_video(3, 0, 2, 31)">二义性文法的使用</li>
      <li onclick="load_video(3, 0, 2, 31)">优先级/结合性消除冲突</li>
      <li onclick="load_video(3, 0, 2, 31)">二义性表达式文法的LR(0)项集</li>
      <li onclick="load_video(3, 0, 2, 31)">冲突的原因以及解决</li>
      <li onclick="load_video(3, 0, 2, 31)">解决冲突之后的SLR(1)分析表</li>
      <li onclick="load_video(3, 0, 2, 31)">悬空else的二义性</li>
      <li onclick="load_video(3, 0, 2, 31)">语法错误的处理</li>
      <li onclick="load_video(3, 0, 2, 31)">预测分析中的错误恢复</li>
      <li onclick="load_video(3, 0, 2, 31)">恐慌模式</li>
      <li onclick="load_video(3, 0, 2, 31)">同步词法单元的确定</li>
      <li onclick="load_video(3, 0, 2, 31)">短语层次的恢复</li>
      <li onclick="load_video(3, 0, 2, 31)">LR语法分析中的错误恢复</li>
      <li onclick="load_video(3, 0, 2, 31)">语法分析器生成工具YACC/Bison</li>
      <li onclick="load_video(3, 0, 2, 31)">YACC源程序的结构</li>
      <li onclick="load_video(3, 0, 2, 31)">翻译规则的格式</li>
      <li onclick="load_video(3, 0, 2, 31)">YACC中的冲突处理</li>
      <li onclick="load_video(3, 0, 2, 31)">YACC中的错误恢复</li>
    </ul>
    <h1>5 语法制导的翻译</h1>
    <ul>
      <li onclick="load_video(3, 0, 2, 31)">语法制导定义和语法制导翻译</li>
      <li onclick="load_video(3, 0, 2, 31)">语法制导的定义(SDD)</li>
      <li onclick="load_video(3, 0, 2, 31)">分析树和属性值</li>
      <li onclick="load_video(3, 0, 2, 31)">综合属性和继承属性</li>
      <li onclick="load_video(3, 0, 2, 31)">SDD的例子</li>
      <li onclick="load_video(3, 0, 2, 31)">S属性的SDD</li>
      <li onclick="load_video(3, 0, 2, 31)">语法分析树上的SDD求值</li>
      <li onclick="load_video(3, 0, 2, 31)">注释分析树的例子</li>
      <li onclick="load_video(3, 0, 2, 31)">适用于自顶向下分析的SDD</li>
      <li onclick="load_video(3, 0, 2, 31)">3 * 5的注释分析树</li>
      <li onclick="load_video(3, 0, 2, 31)">消除直接左递归时语义规则的处理</li>
      <li onclick="load_video(3, 0, 2, 31)">SDD的求值顺序</li>
      <li onclick="load_video(3, 0, 2, 31)">依赖图</li>
      <li onclick="load_video(3, 0, 2, 31)">属性值的计算顺序</li>
      <li onclick="load_video(3, 0, 2, 31)">S属性的SDD</li>
      <li onclick="load_video(3, 0, 2, 31)">在分析树上计算SDD</li>
      <li onclick="load_video(3, 0, 2, 31)">L属性的SDD</li>
      <li onclick="load_video(3, 0, 2, 31)">L属性的SDD和自顶向下语法分析</li>
      <li onclick="load_video(3, 0, 2, 31)">L属性SDD的例子及反例</li>
      <li onclick="load_video(3, 0, 2, 31)">具有受控副作用的语义规则</li>
      <li onclick="load_video(3, 0, 2, 31)">受控副作用的例子</li>
      <li onclick="load_video(3, 0, 2, 31)">SDD的应用例子</li>
      <li onclick="load_video(3, 0, 2, 31)">构造抽象语法树的SDD</li>
      <li onclick="load_video(3, 0, 2, 31)">构造简单表达式的抽象语法树的SDD</li>
      <li onclick="load_video(3, 0, 2, 31)">表达式抽象语法树的构造过程</li>
      <li onclick="load_video(3, 0, 2, 31)">自顶向下方式处理的L属性定义</li>
      <li onclick="load_video(3, 0, 2, 31)">类型结构</li>
      <li onclick="load_video(3, 0, 2, 31)">类型的含义</li>
      <li onclick="load_video(3, 0, 2, 31)">类型表达式的生成过程</li>
      <li onclick="load_video(3, 0, 2, 31)">语法制导的翻译方案</li>
      <li onclick="load_video(3, 0, 2, 31)">可在语法分析过程中实现的SDT</li>
      <li onclick="load_video(3, 0, 2, 31)">SDT可否用特定分析技术实现的例子</li>
      <li onclick="load_video(3, 0, 2, 31)">后缀翻译方案</li>
      <li onclick="load_video(3, 0, 2, 31)">后缀SDT的语法分析栈实现</li>
      <li onclick="load_video(3, 0, 2, 31)">产生式内部带有语义动作的SDT</li>
      <li onclick="load_video(3, 0, 2, 31)">消除左递归时SDT的转换</li>
      <li onclick="load_video(3, 0, 2, 31)">L属性的SDT</li>
      <li onclick="load_video(3, 0, 2, 31)">while语句的SDD和SDT</li>
      <li onclick="load_video(3, 0, 2, 31)">L属性的SDD的例子</li>
      <li onclick="load_video(3, 0, 2, 31)">转换为SDT</li>
      <li onclick="load_video(3, 0, 2, 31)">L属性SDD的实现</li>
      <li onclick="load_video(3, 0, 2, 31)">递归下降实现L属性SDD的例子</li>
      <li onclick="load_video(3, 0, 2, 31)">便扫描便生成属性</li>
    </ul>
    <h1>6 中间代码生成</h1>
    <ul>
      <li onclick="load_video(3, 0, 2, 31)">编译器前端的逻辑结构</li>
      <li onclick="load_video(3, 0, 2, 31)">中间代码表示及其好处</li>
      <li onclick="load_video(3, 0, 2, 31)">中间代码的实现</li>
      <li onclick="load_video(3, 0, 2, 31)">生成抽象语法树的语法制导定义</li>
      <li onclick="load_video(3, 0, 2, 31)">表达式的有向无环图</li>
      <li onclick="load_video(3, 0, 2, 31)">DAG构造</li>
      <li onclick="load_video(3, 0, 2, 31)">三地址代码</li>
      <li onclick="load_video(3, 0, 2, 31)">三地址指令的四元式表示方法</li>
      <li onclick="load_video(3, 0, 2, 31)">三元式表示</li>
      <li onclick="load_video(3, 0, 2, 31)">间接三元式</li>
      <li onclick="load_video(3, 0, 2, 31)">静态单赋值(SSA)</li>
      <li onclick="load_video(3, 0, 2, 31)">类型和声明</li>
      <li onclick="load_video(3, 0, 2, 31)">类型表达式</li>
      <li onclick="load_video(3, 0, 2, 31)">类型等价</li>
      <li onclick="load_video(3, 0, 2, 31)">类型的声明</li>
      <li onclick="load_video(3, 0, 2, 31)">局部变量的存储布局</li>
      <li onclick="load_video(3, 0, 2, 31)">计算T的类型和宽度的SDT</li>
      <li onclick="load_video(3, 0, 2, 31)">SDT运行的例子</li>
      <li onclick="load_video(3, 0, 2, 31)">S声明序列的SDT</li>
      <li onclick="load_video(3, 0, 2, 31)">记录和类中的字段</li>
      <li onclick="load_video(3, 0, 2, 31)">表达式代码的SDD</li>
      <li onclick="load_video(3, 0, 2, 31)">增量式翻译方案</li>
      <li onclick="load_video(3, 0, 2, 31)">数组元素的寻址</li>
      <li onclick="load_video(3, 0, 2, 31)">数组引用的翻译</li>
      <li onclick="load_video(3, 0, 2, 31)">数组引用生成代码的翻译方案</li>
      <li onclick="load_video(3, 0, 2, 31)">类型检查和转换</li>
      <li onclick="load_video(3, 0, 2, 31)">类型系统的分类</li>
      <li onclick="load_video(3, 0, 2, 31)">函数/运算符的重载</li>
      <li onclick="load_video(3, 0, 2, 31)">类型转换</li>
      <li onclick="load_video(3, 0, 2, 31)">类型拓宽widening和窄化narrowing</li>
      <li onclick="load_video(3, 0, 2, 31)">处理类型转化的SDT</li>
      <li onclick="load_video(3, 0, 2, 31)">控制流的翻译</li>
      <li onclick="load_video(3, 0, 2, 31)">短路代码的例子</li>
      <li onclick="load_video(3, 0, 2, 31)">控制流语句的翻译</li>
      <li onclick="load_video(3, 0, 2, 31)">语法制导的定义</li>
      <li onclick="load_video(3, 0, 2, 31)">布尔表达式的控制流翻译</li>
      <li onclick="load_video(3, 0, 2, 31)">布尔表达式的代码的SDD</li>
      <li onclick="load_video(3, 0, 2, 31)">布尔值和跳转代码</li>
      <li onclick="load_video(3, 0, 2, 31)">回填</li>
      <li onclick="load_video(3, 0, 2, 31)">布尔表达式的回填翻译</li>
      <li onclick="load_video(3, 0, 2, 31)">回填和非回填方法的比较</li>
      <li onclick="load_video(3, 0, 2, 31)">布尔表达式的回填例子</li>
      <li onclick="load_video(3, 0, 2, 31)">控制转移语句的回填</li>
      <li onclick="load_video(3, 0, 2, 31)">Break,COntinue的处理</li>
    </ul>
    <h1>7 运行时刻环境</h1>
    <ul>
      <li onclick="load_video(3, 0, 2, 31)">存储分配的典型方式</li>
      <li onclick="load_video(3, 0, 2, 31)">静态和动态存储分配</li>
      <li onclick="load_video(3, 0, 2, 31)">栈式分配</li>
      <li onclick="load_video(3, 0, 2, 31)">活动树</li>
      <li onclick="load_video(3, 0, 2, 31)">活动记录</li>
      <li onclick="load_video(3, 0, 2, 31)">运行时刻栈的例子</li>
      <li onclick="load_video(3, 0, 2, 31)">调用代码序列</li>
      <li onclick="load_video(3, 0, 2, 31)">调用/返回代码序列的要求</li>
      <li onclick="load_video(3, 0, 2, 31)">活动记录的布局原则</li>
      <li onclick="load_video(3, 0, 2, 31)">调用代码序列的例子</li>
      <li onclick="load_video(3, 0, 2, 31)">调用者/被调用者的活动记录</li>
      <li onclick="load_video(3, 0, 2, 31)">栈中的变长数据</li>
      <li onclick="load_video(3, 0, 2, 31)">非局部数据的访问(无嵌套过程)</li>
      <li onclick="load_video(3, 0, 2, 31)">非局部数据的访问(有嵌套过程)</li>
      <li onclick="load_video(3, 0, 2, 31)">嵌套深度</li>
      <li onclick="load_video(3, 0, 2, 31)">访问链和访问链的使用</li>
      <li onclick="load_video(3, 0, 2, 31)">访问链的维护</li>
      <li onclick="load_video(3, 0, 2, 31)">访问链的维护(过程指针型参数)</li>
      <li onclick="load_video(3, 0, 2, 31)">显示表</li>
      <li onclick="load_video(3, 0, 2, 31)">堆管理</li>
      <li onclick="load_video(3, 0, 2, 31)">存储管理器</li>
      <li onclick="load_video(3, 0, 2, 31)">计算机的存储层次结构</li>
      <li onclick="load_video(3, 0, 2, 31)">程序中的局部性</li>
      <li onclick="load_video(3, 0, 2, 31)">对空间的碎片问题</li>
      <li onclick="load_video(3, 0, 2, 31)">堆空间分配方法</li>
      <li onclick="load_video(3, 0, 2, 31)">使用容器的堆管理方法</li>
      <li onclick="load_video(3, 0, 2, 31)">管理和接合空闲空间</li>
      <li onclick="load_video(3, 0, 2, 31)">处理手工存储管理</li>
      <li onclick="load_video(3, 0, 2, 31)">垃圾回收</li>
      <li onclick="load_video(3, 0, 2, 31)">垃圾回收器的设计目标</li>
      <li onclick="load_video(3, 0, 2, 31)">可达性</li>
      <li onclick="load_video(3, 0, 2, 31)">改变可达对象集合的操作</li>
      <li onclick="load_video(3, 0, 2, 31)">垃圾回收方法</li>
      <li onclick="load_video(3, 0, 2, 31)">基于引用计数的垃圾回收器</li>
      <li onclick="load_video(3, 0, 2, 31)">引用计数的例子</li>
      <li onclick="load_video(3, 0, 2, 31)">循环垃圾的例子</li>
      <li onclick="load_video(3, 0, 2, 31)">基于跟踪的垃圾回收</li>
      <li onclick="load_video(3, 0, 2, 31)">标记-清扫式垃圾回收</li>
      <li onclick="load_video(3, 0, 2, 31)">回收算法</li>
      <li onclick="load_video(3, 0, 2, 31)">基本抽象分类</li>
      <li onclick="load_video(3, 0, 2, 31)">标记并压缩垃圾回收</li>
      <li onclick="load_video(3, 0, 2, 31)">拷贝垃圾回收</li>
    </ul>
    <h1>8 代码生成</h1>
    <ul>
      <li onclick="load_video(3, 0, 2, 31)">代码生成器的位置</li>
      <li onclick="load_video(3, 0, 2, 31)">目标机模型</li>
      <li onclick="load_video(3, 0, 2, 31)">寻址模式</li>
      <li onclick="load_video(3, 0, 2, 31)">程序及指令的代价</li>
      <li onclick="load_video(3, 0, 2, 31)">目标代码中的地址</li>
      <li onclick="load_video(3, 0, 2, 31)">活动记录的静态分配</li>
      <li onclick="load_video(3, 0, 2, 31)">活动记录的栈式分配</li>
      <li onclick="load_video(3, 0, 2, 31)">名字的运行时刻地址</li>
      <li onclick="load_video(3, 0, 2, 31)">基本块和流图</li>
      <li onclick="load_video(3, 0, 2, 31)">划分基本块的算法</li>
      <li onclick="load_video(3, 0, 2, 31)">后续使用信息</li>
      <li onclick="load_video(3, 0, 2, 31)">确定基本块中的活跃性,后续使用</li>
      <li onclick="load_video(3, 0, 2, 31)">流图的构造</li>
      <li onclick="load_video(3, 0, 2, 31)">循环</li>
      <li onclick="load_video(3, 0, 2, 31)">基本块的优化</li>
      <li onclick="load_video(3, 0, 2, 31)">DAG图的构造</li>
      <li onclick="load_video(3, 0, 2, 31)">DAG的作用</li>
      <li onclick="load_video(3, 0, 2, 31)">局部公共子表达式</li>
      <li onclick="load_video(3, 0, 2, 31)">消除死代码</li>
      <li onclick="load_video(3, 0, 2, 31)">基于代数恒等式的优化</li>
      <li onclick="load_video(3, 0, 2, 31)">数组引用</li>
      <li onclick="load_video(3, 0, 2, 31)">数组引用DAG的例子</li>
      <li onclick="load_video(3, 0, 2, 31)">指针赋值/过程调用</li>
      <li onclick="load_video(3, 0, 2, 31)">从DAG到基本块</li>
      <li onclick="load_video(3, 0, 2, 31)">重组基本块的例子</li>
      <li onclick="load_video(3, 0, 2, 31)">重组的规则</li>
      <li onclick="load_video(3, 0, 2, 31)">代码生成器</li>
      <li onclick="load_video(3, 0, 2, 31)">算法的基本思想和数据结构</li>
      <li onclick="load_video(3, 0, 2, 31)">代码生成算法</li>
      <li onclick="load_video(3, 0, 2, 31)">getReg函数</li>
      <li onclick="load_video(3, 0, 2, 31)">窥孔优化</li>
      <li onclick="load_video(3, 0, 2, 31)">冗余指令的消除</li>
      <li onclick="load_video(3, 0, 2, 31)">控制流优化</li>
      <li onclick="load_video(3, 0, 2, 31)">代数化简/强度消减和机器特有指令</li>
      <li onclick="load_video(3, 0, 2, 31)">寄存器分配和指派</li>
      <li onclick="load_video(3, 0, 2, 31)">全局寄存器分配</li>
      <li onclick="load_video(3, 0, 2, 31)">树重写实现指令选择</li>
      <li onclick="load_video(3, 0, 2, 31)">目标指令选择</li>
      <li onclick="load_video(3, 0, 2, 31)">一些重写规则</li>
      <li onclick="load_video(3, 0, 2, 31)">覆盖重写过程</li>
      <li onclick="load_video(3, 0, 2, 31)">树翻译方案的工作模式</li>
    </ul>
    <h1>9 机器无关的优化</h1>
    <ul>
      <li onclick="load_video(3, 0, 2, 31)">优化的主要来源</li>
      <li onclick="load_video(3, 0, 2, 31)">优化的例子</li>
      <li onclick="load_video(3, 0, 2, 31)">流图</li>
      <li onclick="load_video(3, 0, 2, 31)">全局公共子表达式</li>
      <li onclick="load_video(3, 0, 2, 31)">复制传播</li>
      <li onclick="load_video(3, 0, 2, 31)">死代码消除</li>
      <li onclick="load_video(3, 0, 2, 31)">代码移动</li>
      <li onclick="load_video(3, 0, 2, 31)">归纳变量和强度消减</li>
      <li onclick="load_video(3, 0, 2, 31)">数据流分析</li>
      <li onclick="load_video(3, 0, 2, 31)">数据流抽象</li>
      <li onclick="load_video(3, 0, 2, 31)">性质和算法</li>
      <li onclick="load_video(3, 0, 2, 31)">数据流分析模式</li>
      <li onclick="load_video(3, 0, 2, 31)">数据流分析</li>
      <li onclick="load_video(3, 0, 2, 31)">基本块内的数据流模式</li>
      <li onclick="load_video(3, 0, 2, 31)">基本块之间的控制流约束</li>
      <li onclick="load_video(3, 0, 2, 31)">数据流方程解的精确性和安全性</li>
      <li onclick="load_video(3, 0, 2, 31)">到达定值</li>
      <li onclick="load_video(3, 0, 2, 31)">语句/基本块的传递方程</li>
      <li onclick="load_video(3, 0, 2, 31)">gen和kill的例子</li>
      <li onclick="load_video(3, 0, 2, 31)">到达定值的控制流方程</li>
      <li onclick="load_video(3, 0, 2, 31)">控制流方程的迭代解法</li>
      <li onclick="load_video(3, 0, 2, 31)">活跃变量分析</li>
      <li onclick="load_video(3, 0, 2, 31)">基本块内的数据流方程</li>
      <li onclick="load_video(3, 0, 2, 31)">use_b和def_b的用法</li>
      <li onclick="load_video(3, 0, 2, 31)">活跃变量数据流方程</li>
      <li onclick="load_video(3, 0, 2, 31)">活跃变量分析的迭代方法</li>
      <li onclick="load_video(3, 0, 2, 31)">可用表达式分析</li>
      <li onclick="load_video(3, 0, 2, 31)">计算基本快生成的表达式</li>
      <li onclick="load_video(3, 0, 2, 31)">基本块生成/杀死的表达式的例子</li>
      <li onclick="load_video(3, 0, 2, 31)">可用表达式的数据流方程</li>
      <li onclick="load_video(3, 0, 2, 31)">可用表达式分析的迭代方法</li>
      <li onclick="load_video(3, 0, 2, 31)">三种数据流方程的总结</li>
      <li onclick="load_video(3, 0, 2, 31)">数据流分析的理论基础</li>
      <li onclick="load_video(3, 0, 2, 31)">部分冗余消除</li>
      <li onclick="load_video(3, 0, 2, 31)">需要添加基本块来消除的冗余</li>
      <li onclick="load_video(3, 0, 2, 31)">懒惰代码移动</li>
      <li onclick="load_video(3, 0, 2, 31)">基本步骤</li>
      <li onclick="load_video(3, 0, 2, 31)">预期执行表达式</li>
      <li onclick="load_video(3, 0, 2, 31)">可用表达式</li>
      <li onclick="load_video(3, 0, 2, 31)">可后延表达式</li>
      <li onclick="load_video(3, 0, 2, 31)">被使用的表达式</li>
      <li onclick="load_video(3, 0, 2, 31)">流图中的循环</li>
      <li onclick="load_video(3, 0, 2, 31)">支配节点</li>
      <li onclick="load_video(3, 0, 2, 31)">支配节点树</li>
      <li onclick="load_video(3, 0, 2, 31)">寻找支配节点算法</li>
      <li onclick="load_video(3, 0, 2, 31)">深度优先生成树</li>
      <li onclick="load_video(3, 0, 2, 31)">深度优先排序</li>
      <li onclick="load_video(3, 0, 2, 31)">深度优先生成树和深度优先排序算法</li>
      <li onclick="load_video(3, 0, 2, 31)">流图中边的分类</li>
      <li onclick="load_video(3, 0, 2, 31)">回边和可归约性</li>
      <li onclick="load_video(3, 0, 2, 31)">流图的深度</li>
      <li onclick="load_video(3, 0, 2, 31)">自然循环</li>
      <li onclick="load_video(3, 0, 2, 31)">自然循环构造算法</li>
    </ul>
  </div>

</body>

</html>